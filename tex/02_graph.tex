\chapter{Графы}
\section{Основы}
Граф - множество вершин и ребер(заданных явно или не явно). Понятия используемые в дальнейшем:
\begin{itemize} 
\item 
    Ациклический граф
    \begin{mydef}
        Граф без циклов
    \end{mydef}
\item     
    Влентность/Степень вершины
    \begin{mydef}
        Количество ребер входящих/выходящих в вершину
    \end{mydef}
\item     
    Взвешенный граф
    \begin{mydef}
        Граф в котором у каждого ребра есть стоимость
    \end{mydef}
\item     
    Висячая вершина
    \begin{mydef}
        Вершина со степенью один
    \end{mydef}
\item     
    Гамильтонов путь
    \begin{mydef}
        Путь в графе содержащий каждую вершину ровно один раз
    \end{mydef}
\item     
    Гамильтонов цикл
    \begin{mydef}
        Цикл содержащий каждую вершину ровно один раз
    \end{mydef}
\item     
    Двудольный граф
    \begin{mydef}
        Граф в котором можно выделить два множества такие, что между         любыми двумя вершинами одного множества нет ребер.
    \end{mydef}
\item     
    Компонента связности
    \begin{mydef}
        Множество вершин и ребер графа такое, что из каждой его вершины
        достижима любая другая вершина этого множества
    \end{mydef}
\item     
    Компонента сильной связности
    \begin{mydef}
        Множество вершин и ребер ориентированного графа такое, что из каждой его           вершины достижима любая другая вершина этого множества
    \end{mydef}
\item     
    Кратные ребра
    \begin{mydef}
        Ребра связывающие одну и ту же пару вершин
    \end{mydef}
\item     
    Минимальный каркас
    \begin{mydef}
        Множество ребер соеденяющих все вершины графа без циклов и имеющее               минимальный суммарный вес
    \end{mydef}
\item     
    Паросочетания
    \begin{mydef}
        Множество попарно не смежных ребер
    \end{mydef}
\item     
    Точка сочленения
    \begin{mydef}
        Вершина после удаления которой количество компонент связности возрастает
    \end{mydef}
\item     
    Эйлеров путь
    \begin{mydef}
        Путь в графе содержащий каждое ребро ровно один раз
    \end{mydef}
\item     
    Эйлеров цикл
    \begin{mydef}
        Цикл содержащий каждое ребро ровно один раз
    \end{mydef}
\end{itemize}
\section{Идентификация графа}
\subsection{Поиск цикла и проверка на ацикличность}
Воспользуемся поиском в глубину. Окрасим все вершины в белый. Запускаясь от вершины перекрашиваем ее в серый, а выходя из нее красим в черный. Если ${dfs}$ попытается пойти в серую вершину, значит мы нашли цикл, который сможем вывести с помощью массива предков, иначе граф циклов не имеет. Далее реализация на списках смежности.
\begin{lstlisting}[language=Python]
bool dfs (int v) {
	cl[v] = 1; //colors
	for (int i = 0; i < g[v].size(); i++) {
		int to = g[v][i];
		if (cl[to] == 0) {
			p[to] = v; 
			if (dfs(to)) //if son have cycle then parent have cycle
			    return true;
		}
		else if (cl[to] == 1) {
			cycle_end = v;
			cycle_st = to;
			return true;
		}
	}
	cl[v] = 2;
	return false;
}
\end{lstlisting}
\subsection{Гамильтонов граф}
Пусть ${n}$ количесттво вершин графа, а ${\delta}$ минимальная степень вершины в графе, тогда граф имеет гамильтонов цикл если ${n\geq 3}$ и ${\delta \geq \frac{n}{2}}$
\subsection{Двудольный граф O($n$)}
Так как граф является двудольным тогда и только тогда, когда все циклы четны, определить двудольность можно за один проход в глубину. На каждом шаге обхода в глубину помечаем вершину. Допустим мы пошли в первую вершину — помечаем её как 1. Затем просматриваем все смежные вершины и если не помечена вершина, то на ней ставим пометку 2 и рекурсивно переходим в нее. Если же она помечена и на ней стоит та же пометка, что и у той, из которой шли (в нашем случае 1), значит граф не двудольный.
\begin{lstlisting}[language=C++]
bool dfs (int v, int c) {
	cl[v] = c; //colors
	for (int i = 0; i < g[v].size(); i++) {
		int to = g[v][i];
		if (cl[to] == 0) {
		    return dfs(to, max(1, (c + 1) % 2));
		}
		else 
		    return cl[to] != c;
	}
}
\end{lstlisting}
\subsection{Компоненты связности O($n$)}
Поиск компонент свзязности можно осуществить многими методами, в том числе и поиском в глубину. Окрасим все вершины в индивидуальные цвета. Запуская $[dfs]$ от каждой вершины будем перекрашивать в ее цвет все вершины в этой компоненте. В конце алгоритма у нас останется столько цветов, сколько компонент связности в графе, а цвет каждой вершины будет идентифицировать ее компоненту.
\begin{lstlisting}[language=C++]
void dfs (int v, int c) {
    if (!used[v])
        return;
	cl[v] = c; //colors
	for (int i = 0; i < g[v].size(); i++) {
		int to = g[v][i];
		if (cl[to]!= cl[v]) {
		    dfs(to, c);
		    return;
		}
}
int main(){
    ...
    for (int i = 0; i < N; i++){
        dfs(i, i);
    }
}
\end{lstlisting}
\subsection{Компоненты сильной связности O($n+m$)}
Решим эту задачу за несколько обходов в глубину. Сначала топологически (по времени выхода) отсортируем граф, затем обойдем транспонированый(инвертированый) граф в этом порядке. Найденые компоненты связности этого графа и будут компонентами сильной связности исходного графа.
\begin{lstlisting}[language=C++]
vector < vector<int> > g, gr; // граф и транспортированый граф
vector<char> used;
vector<int> order, component; // порядок топ сорта и компонента сильной связности
 
void dfs1 (int v) {
	used[v] = true;
	for (int i = 0; i < g[v].size(); i++)
		if (!used[g[v][i]])
			dfs1(g[v][i]);
	order.push_back(v);
}
 
void dfs2 (int v) {
	used[v] = true;
	component.push_back(v);
	for (int i = 0; i < gr[v].size(); i++)
		if (!used[gr[v][i]])
			dfs2(gr[v][i]);
}
 
int main() {
	int n, m;
	cin >> n >> m;
	for (int i = 0; i < m; i++){
		int a, b;
		cin >> a >> b;
		g[a].push_back(b);
		gr[b].push_back(a);
	}
 
	used.assign(n, false);
	for (int i = 0; i < n; i++)
		if (!used[i])
			dfs1(i);
	used.assign(n, false);
	for (int i = 0; i < n; i++) {
		int v = order[n - 1 - i];
		if (!used[v]) {
			dfs2 (v);
			//... вывод component ...
			component.clear();
		}
	}
}
\end{lstlisting}
\subsection{Минимальное остовное дерево O($M*log(M)$)}
Алгоритм Кр(а|у)скала. Составим список ребер, отсортируем их по возрастанию весов. Распределим все вершины в соответствующие им множества, для работы с ними воспользуемся СНМ. Будем добавлять ребра по порядку, но только, если они соединяют вершины из разных множеств. После этого объединим их множества.
\begin{lstlisting}[language=C++]
vector<int> p (n);//Множества

int dsu_get(int v) {
	return(v == p[v]) ? v : (p[v] = dsu_get(p[v]));
}

void dsu_unite(int a, int b) {
	a = dsu_get(a);
	b = dsu_get(b);
	if (rand() & 1)
		swap(a, b);
	if (a != b)
		p[a] = b;
}

int main(){
            .....
sort (g.begin(), g.end()); // список ребер <pair<вес, pair<начало, конец> > > 
p.resize (n);
for (int i = 0; i < n; i++)
	p[i] = i;
for (int i = 0; i < m; i++) {
	int a = g[i].second.first,  b = g[i].second.second,  l = g[i].first;
	if (dsu_get(a) != dsu_get(b)) {
		cost += l; // вес каркаса
		res.push_back(g[i].second); // каркас
		dsu_unite(a, b);
	}
}
\end{lstlisting}
