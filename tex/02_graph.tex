\chapter{Графы}
\section{Основы}
Граф - множество вершин и ребер(заданных явно или не явно). Понятия используемые в дальнейшем:
\begin{itemize} 
\item 
    Ациклический граф
    \begin{mydef}
        Граф без циклов
    \end{mydef}
\item     
    Влентность/Степень вершины
    \begin{mydef}
        Количество ребер входящих/выходящих в вершину
    \end{mydef}
\item     
    Взвешенный граф
    \begin{mydef}
        Граф в котором у каждого ребра есть стоимость
    \end{mydef}
\item     
    Висячая вершина
    \begin{mydef}
        Вершина со степенью один
    \end{mydef}
\item     
    Гамильтонов путь
    \begin{mydef}
        Путь в графе содержащий каждую вершину ровно один раз
    \end{mydef}
\item     
    Гамильтонов цикл
    \begin{mydef}
        Цикл содержащий каждую вершину ровно один раз
    \end{mydef}
\item     
    Двудольный граф
    \begin{mydef}
        Граф в котором можно выделить два множества такие, что между         любыми двумя вершинами одного множества нет ребер.
    \end{mydef}
\item     
    Компонента связности
    \begin{mydef}
        Множество вершин и ребер графа такое, что из каждой его вершины
        достижима любая другая вершина этого множества
    \end{mydef}
\item     
    Компонента сильной связности
    \begin{mydef}
        Множество вершин и ребер ориентированного графа такое, что из каждой его           вершины достижима любая другая вершина этого множества
    \end{mydef}
\item     
    Кратные ребра
    \begin{mydef}
        Ребра связывающие одну и ту же пару вершин
    \end{mydef}
\item     
    Минимальный каркас
    \begin{mydef}
        Множество ребер соеденяющих все вершины графа без циклов и имеющее               минимальный суммарный вес
    \end{mydef}
\item     
    Паросочетания
    \begin{mydef}
        Множество попарно не смежных ребер
    \end{mydef}
\item     
    Точка сочленения
    \begin{mydef}
        Вершина после удаления которой количество компонент связности возрастает
    \end{mydef}
\item     
    Эйлеров путь
    \begin{mydef}
        Путь в графе содержащий каждое ребро ровно один раз
    \end{mydef}
\item     
    Эйлеров цикл
    \begin{mydef}
        Цикл содержащий каждое ребро ровно один раз
    \end{mydef}
\end{itemize}
\section{Идентификация графа}
\subsection{Поиск цикла и проверка на ацикличность}
Воспользуемся поиском в глубину. Окрасим все вершины в белый. Запускаясь от вершины перекрашиваем ее в серый, а выходя из нее красим в черный. Если ${dfs}$ попытается пойти в серую вершину, значит мы нашли цикл, который сможем вывести с помощью массива предков, иначе граф циклов не имеет. Далее реализация на списках смежности.
\begin{lstlisting}[language=Python]
bool dfs (int v) {
	cl[v] = 1; //colors
	for (int i = 0; i < g[v].size(); i++) {
		int to = g[v][i];
		if (cl[to] == 0) {
			p[to] = v; 
			if (dfs(to)) //if son have cycle then parent have cycle
			    return true;
		}
		else if (cl[to] == 1) {
			cycle_end = v;
			cycle_st = to;
			return true;
		}
	}
	cl[v] = 2;
	return false;
}
\end{lstlisting}
\subsection{Гамильтонов граф}
Пусть ${n}$ количесттво вершин графа, а ${\delta}$ минимальная степень вершины в графе, тогда граф имеет гамильтонов цикл если ${n\geq 3}$ и ${\delta \geq \frac{n}{2}}$
\subsection{Двудольный граф}
Так как граф является двудольным тогда и только тогда, когда все циклы четны, определить двудольность можно за один проход в глубину. На каждом шаге обхода в глубину помечаем вершину. Допустим мы пошли в первую вершину — помечаем её как 1. Затем просматриваем все смежные вершины и если не помечена вершина, то на ней ставим пометку 2 и рекурсивно переходим в нее. Если же она помечена и на ней стоит та же пометка, что и у той, из которой шли (в нашем случае 1), значит граф не двудольный.
\begin{lstlisting}[language=C++]
bool dfs (int v, int c) {
	cl[v] = c; // с - цвет текущей вершины
	for (int i = 0; i < g[v].size(); i++) {
		int to = g[v][i];
		if (cl[to] == 0) {
		    return dfs(to, max(1, (c + 1) \% 2));
		}
		else 
		    return cl[to] != с;
	}
}
\end{lstlisting}
